initSidebarItems({"constant":[["INT16_MAX",""],["INT16_MIN",""],["INT32_MAX",""],["INT32_MIN",""],["INT8_MAX",""],["INT8_MIN",""],["INTPTR_MAX",""],["INTPTR_MIN",""],["INT_FAST16_MAX",""],["INT_FAST16_MIN",""],["INT_FAST32_MAX",""],["INT_FAST32_MIN",""],["INT_FAST8_MAX",""],["INT_FAST8_MIN",""],["INT_LEAST16_MAX",""],["INT_LEAST16_MIN",""],["INT_LEAST32_MAX",""],["INT_LEAST32_MIN",""],["INT_LEAST8_MAX",""],["INT_LEAST8_MIN",""],["PTRDIFF_MAX",""],["PTRDIFF_MIN",""],["SIG_ATOMIC_MAX",""],["SIG_ATOMIC_MIN",""],["SIZE_MAX",""],["UINT16_MAX",""],["UINT32_MAX",""],["UINT8_MAX",""],["UINTPTR_MAX",""],["UINT_FAST16_MAX",""],["UINT_FAST32_MAX",""],["UINT_FAST8_MAX",""],["UINT_LEAST16_MAX",""],["UINT_LEAST32_MAX",""],["UINT_LEAST8_MAX",""],["WINT_MAX",""],["WINT_MIN",""],["XED_64B",""],["XED_EMIT_MESSAGES",""],["XED_ENCODER_OPERANDS_MAX",""],["XED_ENCODE_FB_VALUES_TABLE_SIZE",""],["XED_ENCODE_MAX_EMIT_PATTERNS",""],["XED_ENCODE_MAX_FB_PATTERNS",""],["XED_ENCODE_MAX_IFORMS",""],["XED_ENCODE_ORDER_MAX_ENTRIES",""],["XED_ENCODE_ORDER_MAX_OPERANDS",""],["XED_ENC_GROUPS",""],["XED_FEATURE_VECTOR_MAX",""],["XED_FMT_08X",""],["XED_FMT_9U",""],["XED_FMT_D",""],["XED_FMT_LD",""],["XED_FMT_LU",""],["XED_FMT_LU12",""],["XED_FMT_LX",""],["XED_FMT_LX16",""],["XED_FMT_LX16_UPPER",""],["XED_FMT_LX_UPPER",""],["XED_FMT_SIZET",""],["XED_FMT_U",""],["XED_FMT_X",""],["XED_GIT_VERSION",""],["XED_ICLASS_NAME_STR_MAX",""],["XED_INFO2_VERBOSE",""],["XED_INFO_VERBOSE",""],["XED_MAX_ATTRIBUTE_COUNT",""],["XED_MAX_CONVERT_PATTERNS",""],["XED_MAX_CPUID_BITS_PER_ISA_SET",""],["XED_MAX_DECORATIONS_PER_OPERAND",""],["XED_MAX_DISPLACEMENT_BYTES",""],["XED_MAX_GLOBAL_FLAG_ACTIONS",""],["XED_MAX_IFORMS_PER_ICLASS",""],["XED_MAX_IMMEDIATE_BYTES",""],["XED_MAX_INSTRUCTION_BYTES",""],["XED_MAX_INST_TABLE_NODES",""],["XED_MAX_OPERAND_SEQUENCES",""],["XED_MAX_OPERAND_TABLE_NODES",""],["XED_MAX_REQUIRED_ATTRIBUTES",""],["XED_MAX_REQUIRED_COMPLEX_FLAGS_ENTRIES",""],["XED_MAX_REQUIRED_SIMPLE_FLAGS_ENTRIES",""],["XED_MORE_VERBOSE",""],["XED_VERBOSE",""],["XED_VERY_VERBOSE",""],["_ATFILE_SOURCE",""],["_BITS_WCHAR_H",""],["_DEFAULT_SOURCE",""],["_FEATURES_H",""],["_POSIX_C_SOURCE",""],["_POSIX_SOURCE",""],["_STDC_PREDEF_H",""],["_STDINT_H",""],["_SYS_CDEFS_H",""],["__GLIBC_MINOR__",""],["__GLIBC__",""],["__GNU_LIBRARY__",""],["__STDC_IEC_559_COMPLEX__",""],["__STDC_IEC_559__",""],["__STDC_ISO_10646__",""],["__STDC_NO_THREADS__",""],["__SYSCALL_WORDSIZE",""],["__USE_ATFILE",""],["__USE_FORTIFY_LEVEL",""],["__USE_ISOC11",""],["__USE_ISOC95",""],["__USE_ISOC99",""],["__USE_MISC",""],["__USE_POSIX",""],["__USE_POSIX199309",""],["__USE_POSIX199506",""],["__USE_POSIX2",""],["__USE_POSIX_IMPLICITLY",""],["__USE_XOPEN2K",""],["__USE_XOPEN2K8",""],["__WORDSIZE",""],["__WORDSIZE_TIME64_COMPAT32",""],["xed_iformfl_enum_t_XED_IFORMFL_AAA_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_AAD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_AAM_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_AAS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_BNDMK_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_BSWAP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CBW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CDQE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CDQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLAC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLFLUSHOPT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLFLUSH_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLGI_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLI_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLRSSBSY_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLTS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLWB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CLZERO_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CMC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CMPSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CMPSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CMPSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CMPSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CMPXCHG16B_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CMPXCHG16B_LOCK_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CMPXCHG8B_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CMPXCHG8B_LOCK_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CPUID_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CQO_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CWDE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_CWD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_DAA_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_DAS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_EMMS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_ENCLS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_ENCLU_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_ENDBR32_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_ENDBR64_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_ENTER_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_F2XM1_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FABS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FADDP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FBLD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FBSTP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCHS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCMOVBE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCMOVB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCMOVE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCMOVNBE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCMOVNB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCMOVNE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCMOVNU_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCMOVU_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCOMIP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCOMI_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCOMPP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FCOS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FDECSTP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FDISI8087_NOP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FDIVP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FDIVRP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FEMMS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FENI8087_NOP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FFREEP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FFREE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FINCSTP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FLD1_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FLDCW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FLDL2E_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FLDL2T_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FLDLG2_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FLDLN2_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FLDPI_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FLDZ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FMULP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FNCLEX_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FNINIT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FNOP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FNSTCW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FPATAN_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FPREM1_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FPREM_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FPTAN_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FRNDINT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FSCALE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FSETPM287_NOP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FSINCOS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FSIN_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FSQRT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FSTPNCE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FSUBP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FSUBRP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FTST_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FUCOMIP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FUCOMI_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FUCOMPP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FUCOMP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FUCOM_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FWAIT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FXAM_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FXRSTOR64_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FXRSTOR_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FXSAVE64_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FXSAVE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FXTRACT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FYL2XP1_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_FYL2X_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_GETSEC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_HLT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INCSSPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INCSSPQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INT1_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INT3_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INTO_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INVD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INVLPGA_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_INVLPG_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_IRETD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_IRETQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_IRET_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_JCXZ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_JECXZ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_JRCXZ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KADDB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KADDD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KADDQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KADDW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KANDB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KANDD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KANDNB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KANDND_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KANDNQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KANDNW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KANDQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KANDW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KNOTB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KNOTD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KNOTQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KNOTW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KORB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KORD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KORQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KORTESTB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KORTESTD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KORTESTQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KORTESTW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KORW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KSHIFTLB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KSHIFTLD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KSHIFTLQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KSHIFTLW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KSHIFTRB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KSHIFTRD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KSHIFTRQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KSHIFTRW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KTESTB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KTESTD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KTESTQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KTESTW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KUNPCKBW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KUNPCKDQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KUNPCKWD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KXNORB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KXNORD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KXNORQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KXNORW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KXORB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KXORD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KXORQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_KXORW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LAHF_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LDDQU_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LDMXCSR_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LDS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LEAVE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LEA_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LES_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LFENCE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LFS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LGS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LLWPCB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LODSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LODSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LODSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LODSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LOOPE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LOOPNE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LOOP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_LSS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MASKMOVDQU_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MASKMOVQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MFENCE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MONITOR_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVDQ2Q_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVHLPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVLHPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVMSKPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVMSKPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVNTDQA_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVNTDQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVNTPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVNTPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVNTQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVNTSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVNTSS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVQ2DQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MOVSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_MWAIT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_OUTSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_OUTSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_OUTSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PAUSE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_POPAD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_POPA_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_POPFD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_POPFQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_POPF_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PREFETCHNTA_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PREFETCHT0_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PREFETCHT1_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PREFETCHT2_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PREFETCHWT1_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PREFETCH_EXCLUSIVE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PSLLDQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PSRLDQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PUSHAD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PUSHA_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PUSHFD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PUSHFQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_PUSHF_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDFSBASE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDGSBASE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDMSR_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDPKRU_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDPMC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDRAND_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDSEED_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDSSPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDSSPQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDTSCP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RDTSC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPE_CMPSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPE_CMPSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPE_CMPSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPE_CMPSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPE_SCASB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPE_SCASD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPE_SCASQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPE_SCASW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPNE_CMPSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPNE_CMPSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPNE_CMPSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPNE_CMPSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPNE_SCASB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPNE_SCASD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPNE_SCASQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REPNE_SCASW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_INSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_INSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_INSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_LODSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_LODSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_LODSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_LODSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_MOVSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_MOVSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_MOVSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_MOVSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_OUTSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_OUTSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_OUTSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_STOSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_STOSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_STOSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_REP_STOSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RSM_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_RSTORSSP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SAHF_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SALC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SAVESSP_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SCASB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SCASD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SCASQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SCASW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SETSSBSY_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SFENCE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SKINIT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SLWPCB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_STAC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_STC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_STD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_STGI_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_STI_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_STMXCSR_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_STOSB_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_STOSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_STOSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_STOSW_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SWAPGS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SYSCALL_AMD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SYSCALL_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SYSENTER_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SYSEXIT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SYSRET_AMD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_SYSRET_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_UD0_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_UD2_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_V4FMADDPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_V4FMADDSS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_V4FNMADDPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_V4FNMADDSS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VBROADCASTF128_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VBROADCASTF32X8_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VBROADCASTF64X4_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VBROADCASTI128_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VBROADCASTI32X8_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VBROADCASTI64X4_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VGATHERPF0DPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VGATHERPF0DPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VGATHERPF0QPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VGATHERPF0QPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VGATHERPF1DPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VGATHERPF1DPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VGATHERPF1QPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VGATHERPF1QPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VLDMXCSR_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMASKMOVDQU_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMCALL_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMCLEAR_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMFUNC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMLAUNCH_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMLOAD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMMCALL_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMPTRLD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMPTRST_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMRESUME_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMRUN_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMSAVE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMXOFF_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VMXON_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VP4DPWSSDS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VP4DPWSSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VSCATTERPF0DPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VSCATTERPF0DPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VSCATTERPF0QPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VSCATTERPF0QPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VSCATTERPF1DPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VSCATTERPF1DPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VSCATTERPF1QPD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VSCATTERPF1QPS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VSTMXCSR_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VZEROALL_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_VZEROUPPER_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_WBINVD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_WRFSBASE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_WRGSBASE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_WRMSR_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_WRPKRU_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_WRSSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_WRSSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_WRUSSD_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_WRUSSQ_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XABORT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XBEGIN_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XEND_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XGETBV_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XLAT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XRSTOR64_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XRSTORS64_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XRSTORS_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XRSTOR_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XSAVE64_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XSAVEC64_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XSAVEC_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XSAVEOPT64_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XSAVEOPT_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XSAVES64_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XSAVES_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XSAVE_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XSETBV_LAST",""],["xed_iformfl_enum_t_XED_IFORMFL_XTEST_LAST",""],["xed_reg_enum_t_XED_REG_BNDCFG_FIRST",""],["xed_reg_enum_t_XED_REG_BNDCFG_LAST",""],["xed_reg_enum_t_XED_REG_BNDSTAT_FIRST",""],["xed_reg_enum_t_XED_REG_BNDSTAT_LAST",""],["xed_reg_enum_t_XED_REG_BOUND_FIRST",""],["xed_reg_enum_t_XED_REG_BOUND_LAST",""],["xed_reg_enum_t_XED_REG_CR_FIRST",""],["xed_reg_enum_t_XED_REG_CR_LAST",""],["xed_reg_enum_t_XED_REG_DR_FIRST",""],["xed_reg_enum_t_XED_REG_DR_LAST",""],["xed_reg_enum_t_XED_REG_FLAGS_FIRST",""],["xed_reg_enum_t_XED_REG_FLAGS_LAST",""],["xed_reg_enum_t_XED_REG_GPR16_FIRST",""],["xed_reg_enum_t_XED_REG_GPR16_LAST",""],["xed_reg_enum_t_XED_REG_GPR32_FIRST",""],["xed_reg_enum_t_XED_REG_GPR32_LAST",""],["xed_reg_enum_t_XED_REG_GPR64_FIRST",""],["xed_reg_enum_t_XED_REG_GPR64_LAST",""],["xed_reg_enum_t_XED_REG_GPR8_FIRST",""],["xed_reg_enum_t_XED_REG_GPR8_LAST",""],["xed_reg_enum_t_XED_REG_GPR8h_FIRST",""],["xed_reg_enum_t_XED_REG_GPR8h_LAST",""],["xed_reg_enum_t_XED_REG_INVALID_FIRST",""],["xed_reg_enum_t_XED_REG_INVALID_LAST",""],["xed_reg_enum_t_XED_REG_IP_FIRST",""],["xed_reg_enum_t_XED_REG_IP_LAST",""],["xed_reg_enum_t_XED_REG_MASK_FIRST",""],["xed_reg_enum_t_XED_REG_MASK_LAST",""],["xed_reg_enum_t_XED_REG_MMX_FIRST",""],["xed_reg_enum_t_XED_REG_MMX_LAST",""],["xed_reg_enum_t_XED_REG_MSR_FIRST",""],["xed_reg_enum_t_XED_REG_MSR_LAST",""],["xed_reg_enum_t_XED_REG_MXCSR_FIRST",""],["xed_reg_enum_t_XED_REG_MXCSR_LAST",""],["xed_reg_enum_t_XED_REG_PSEUDOX87_FIRST",""],["xed_reg_enum_t_XED_REG_PSEUDOX87_LAST",""],["xed_reg_enum_t_XED_REG_PSEUDO_FIRST",""],["xed_reg_enum_t_XED_REG_PSEUDO_LAST",""],["xed_reg_enum_t_XED_REG_SR_FIRST",""],["xed_reg_enum_t_XED_REG_SR_LAST",""],["xed_reg_enum_t_XED_REG_TMP_FIRST",""],["xed_reg_enum_t_XED_REG_TMP_LAST",""],["xed_reg_enum_t_XED_REG_X87_FIRST",""],["xed_reg_enum_t_XED_REG_X87_LAST",""],["xed_reg_enum_t_XED_REG_XCR_FIRST",""],["xed_reg_enum_t_XED_REG_XCR_LAST",""],["xed_reg_enum_t_XED_REG_XMM_FIRST",""],["xed_reg_enum_t_XED_REG_XMM_LAST",""],["xed_reg_enum_t_XED_REG_YMM_FIRST",""],["xed_reg_enum_t_XED_REG_YMM_LAST",""],["xed_reg_enum_t_XED_REG_ZMM_FIRST",""],["xed_reg_enum_t_XED_REG_ZMM_LAST",""]],"enum":[["xed_address_width_enum_t",""],["xed_attribute_enum_t",""],["xed_category_enum_t",""],["xed_chip_enum_t",""],["xed_cpuid_bit_enum_t",""],["xed_encoder_operand_type_t",""],["xed_error_enum_t",""],["xed_exception_enum_t",""],["xed_extension_enum_t",""],["xed_flag_action_enum_t",""],["xed_flag_enum_t",""],["xed_iclass_enum_t",""],["xed_iform_enum_t",""],["xed_iformfl_enum_t",""],["xed_isa_set_enum_t",""],["xed_machine_mode_enum_t",""],["xed_nonterminal_enum_t",""],["xed_operand_action_enum_t",""],["xed_operand_convert_enum_t",""],["xed_operand_element_type_enum_t",""],["xed_operand_element_xtype_enum_t",""],["xed_operand_enum_t",""],["xed_operand_type_enum_t",""],["xed_operand_visibility_enum_t",""],["xed_operand_width_enum_t",""],["xed_reg_class_enum_t",""],["xed_reg_enum_t",""],["xed_syntax_enum_t",""]],"fn":[["str2xed_address_width_enum_t",""],["str2xed_attribute_enum_t",""],["str2xed_category_enum_t",""],["str2xed_chip_enum_t",""],["str2xed_cpuid_bit_enum_t",""],["str2xed_error_enum_t",""],["str2xed_exception_enum_t",""],["str2xed_extension_enum_t",""],["str2xed_flag_action_enum_t",""],["str2xed_flag_enum_t",""],["str2xed_iclass_enum_t",""],["str2xed_iform_enum_t",""],["str2xed_isa_set_enum_t",""],["str2xed_machine_mode_enum_t",""],["str2xed_nonterminal_enum_t",""],["str2xed_operand_action_enum_t",""],["str2xed_operand_convert_enum_t",""],["str2xed_operand_element_type_enum_t",""],["str2xed_operand_element_xtype_enum_t",""],["str2xed_operand_enum_t",""],["str2xed_operand_type_enum_t",""],["str2xed_operand_visibility_enum_t",""],["str2xed_operand_width_enum_t",""],["str2xed_reg_class_enum_t",""],["str2xed_reg_enum_t",""],["str2xed_syntax_enum_t",""],["xed3_get_generic_operand",""],["xed3_set_generic_operand",""],["xed_address_width_enum_t2str",""],["xed_address_width_enum_t_last",""],["xed_agen","Using the registered callbacks, compute the memory address for a specified memop in a decoded instruction. memop_index can have the value 0 for XED_OPERAND_MEM0, XED_OPERAND_AGEN, or 1 for XED_OPERAND_MEM1. Any other value results in an error being returned. The context parameter which is passed to the registered callbacks can be used to identify which thread's state is being referenced. The context parameter can also be used to specify which element of a vector register should be returned for gather an scatter operations. @ingroup AGEN"],["xed_agen_register_callback","Initialize the callback functions. Tell XED what to call when using #xed_agen.  @ingroup AGEN"],["xed_attribute","@ingroup DEC Return the i'th global attribute in a linear sequence, independent of any instruction. This is used for scanning and printing all attributes."],["xed_attribute_enum_t2str",""],["xed_attribute_enum_t_last",""],["xed_attribute_max","@ingroup DEC Return the maximum number of defined attributes, independent of any instruction."],["xed_category_enum_t2str",""],["xed_category_enum_t_last",""],["xed_chip_enum_t2str",""],["xed_chip_enum_t_last",""],["xed_classify_avx","@ingroup DEC True for AVX/AVX2 SIMD VEX-encoded operations. Does not include BMI/BMI2 instructions."],["xed_classify_avx512","@ingroup DEC True for AVX512 (EVEX-encoded) SIMD and (VEX encoded) K-mask instructions"],["xed_classify_avx512_maskop","@ingroup DEC True for AVX512 (VEX-encoded) K-mask operations"],["xed_classify_sse","@ingroup DEC True for SSE/SSE2/etc. SIMD operations.  Includes AES and PCLMULQDQ"],["xed_convert_to_encoder_request","@ingroup ENCHL convert a #xed_encoder_instruction_t to a #xed_encoder_request_t for encoding"],["xed_cpuid_bit_enum_t2str",""],["xed_cpuid_bit_enum_t_last",""],["xed_decode","This is the main interface to the decoder.  @param xedd the decoded instruction of type #xed_decoded_inst_t . Mode/state sent in via xedd; See the #xed_state_t  @param itext the pointer to the array of instruction text bytes  @param bytes  the length of the itext input array. 1 to 15 bytes, anything more is ignored.  @return #xed_error_enum_t indicating success (#XED_ERROR_NONE) or failure. Note failure can be due to not  enough bytes in the input array."],["xed_decode_with_features","@ingroup DEC See #xed_decode(). This version of the decode API adds a CPUID feature vector to support restricting decode based on both a specified chip via #xed_decoded_inst_set_input_chip() and a modify-able cpuid feature vector obtained from #xed_get_chip_features()."],["xed_decoded_inst_conditionally_writes_registers","@ingroup DEC"],["xed_decoded_inst_dump","@ingroup PRINT Print out all the information about the decoded instruction to the buffer buf whose length is maximally buflen. This is for debugging."],["xed_decoded_inst_dump_xed_format","@ingroup PRINT Print the instruction information in a verbose format. This is for debugging. @param p a #xed_decoded_inst_t for a decoded instruction @param buf a buffer to write the disassembly in to. @param buflen maximum length of the disassembly buffer @param runtime_address the address of the instruction being disassembled. If zero, the offset is printed for relative branches. If nonzero, XED attempts to print the target address for relative branches. @return Returns 0 if the disassembly fails, 1 otherwise."],["xed_decoded_inst_get_attribute","@ingroup DEC Returns 1 if the attribute is defined for this instruction."],["xed_decoded_inst_get_attributes","@ingroup DEC Returns the attribute bitvector"],["xed_decoded_inst_get_base_reg","@ingroup DEC"],["xed_decoded_inst_get_branch_displacement","@ingroup DEC"],["xed_decoded_inst_get_branch_displacement_width","@ingroup DEC Result in BYTES"],["xed_decoded_inst_get_branch_displacement_width_bits","@ingroup DEC Result in BITS"],["xed_decoded_inst_get_immediate_is_signed","@ingroup DEC Return true if the first immediate (IMM0)  is signed"],["xed_decoded_inst_get_immediate_width","@ingroup DEC Return the immediate width in BYTES."],["xed_decoded_inst_get_immediate_width_bits","@ingroup DEC Return the immediate width in BITS."],["xed_decoded_inst_get_index_reg",""],["xed_decoded_inst_get_memop_address_width","@ingroup DEC"],["xed_decoded_inst_get_memory_displacement","@ingroup DEC"],["xed_decoded_inst_get_memory_displacement_width","@ingroup DEC Result in BYTES"],["xed_decoded_inst_get_memory_displacement_width_bits","@ingroup DEC Result in BITS"],["xed_decoded_inst_get_memory_operand_length","returns bytes @ingroup DEC"],["xed_decoded_inst_get_modrm","@ingroup DEC Returns the modrm byte"],["xed_decoded_inst_get_nprefixes","@ingroup DEC Returns the number of legacy prefixes."],["xed_decoded_inst_get_operand_width","Returns the operand width in bits: 8/16/32/64. This is different than the #xed_operand_values_get_effective_operand_width() which only returns 16/32/64. This factors in the BYTEOP attribute when computing its return value. This function provides a information for that is only useful for (scalable) GPR-operations. Individual operands have more specific information available from #xed_decoded_inst_operand_element_size_bits() @ingroup DEC"],["xed_decoded_inst_get_reg","@ingroup DEC Return the specified register operand. The specifier is of type #xed_operand_enum_t ."],["xed_decoded_inst_get_rflags_info","See the comment on xed_decoded_inst_uses_rflags(). This can return  0 if the flags are really not used by this instruction. @ingroup DEC"],["xed_decoded_inst_get_scale","@ingroup DEC"],["xed_decoded_inst_get_seg_reg","@ingroup DEC"],["xed_decoded_inst_get_signed_immediate","@ingroup DEC"],["xed_decoded_inst_get_unsigned_immediate","@ingroup DEC"],["xed_decoded_inst_has_mpx_prefix","@ingroup DEC Returns 1 if the instruction has mpx prefix."],["xed_decoded_inst_is_broadcast","@ingroup DEC Return 1 for broadcast instructions or AVX512 load-op instructions using the broadcast feature 0 otherwise.  Logical OR of #xed_decoded_inst_is_broadcast_instruction() and #xed_decoded_inst_uses_embedded_broadcast()."],["xed_decoded_inst_is_broadcast_instruction","@ingroup DEC Return 1 for broadcast instruction. (NOT including AVX512 load-op instructions) 0 otherwise. Just a category check. "],["xed_decoded_inst_is_prefetch","@ingroup DEC Returns true if the instruction is a prefetch"],["xed_decoded_inst_is_xacquire","@ingroup DEC Returns 1 if the instruction is xacquire."],["xed_decoded_inst_is_xrelease","@ingroup DEC Returns 1 if the instruction is xrelease."],["xed_decoded_inst_masked_vector_operation","@ingroup DEC Returns 1 iff the instruction uses destination-masking.  This is 0 for blend operations that use their mask field as a control."],["xed_decoded_inst_masking","Returns true if the instruction uses write-masking @ingroup DEC"],["xed_decoded_inst_mem_read","@ingroup DEC"],["xed_decoded_inst_mem_written","@ingroup DEC"],["xed_decoded_inst_mem_written_only","@ingroup DEC"],["xed_decoded_inst_merging","Returns true if the instruction uses write-masking with merging @ingroup DEC"],["xed_decoded_inst_number_of_memory_operands","@ingroup DEC"],["xed_decoded_inst_operand_action","Interpret the operand action in light of AVX512 masking and zeroing/merging.  If masking and merging are used together, the dest operand may also be read.  If masking and merging are used together, the elemnents of dest operand register may be conditionally written (so that input values live on in the output register). @ingroup DEC"],["xed_decoded_inst_operand_element_size_bits","Return the size of an element in bits  (for SSE and AVX operands) @ingroup DEC"],["xed_decoded_inst_operand_element_type","Return the type of an element of type #xed_operand_element_type_enum_t (for SSE and AVX operands) @ingroup DEC"],["xed_decoded_inst_operand_elements","Return the number of element in the operand (for SSE and AVX operands) @ingroup DEC"],["xed_decoded_inst_operand_length","Deprecated -- returns the length in bytes of the operand_index'th operand.  Use #xed_decoded_inst_operand_length_bits() instead. @ingroup DEC"],["xed_decoded_inst_operand_length_bits","Return the length in bits of the operand_index'th operand. @ingroup DEC"],["xed_decoded_inst_set_branch_displacement","@ingroup DEC Set the branch  displacement using a BYTE length"],["xed_decoded_inst_set_branch_displacement_bits","@ingroup DEC Set the branch displacement a BITS length"],["xed_decoded_inst_set_immediate_signed","@ingroup DEC Set the signed immediate a BYTE length"],["xed_decoded_inst_set_immediate_signed_bits","@ingroup DEC Set the signed immediate a BITS length"],["xed_decoded_inst_set_immediate_unsigned","@ingroup DEC Set the unsigned immediate a BYTE length"],["xed_decoded_inst_set_immediate_unsigned_bits","@ingroup DEC Set the unsigned immediate a BITS length"],["xed_decoded_inst_set_memory_displacement","@ingroup DEC Set the memory displacement using a BYTE length"],["xed_decoded_inst_set_memory_displacement_bits","@ingroup DEC Set the memory displacement a BITS length"],["xed_decoded_inst_set_scale","@ingroup DEC"],["xed_decoded_inst_uses_embedded_broadcast","@ingroup DEC Return 1 for AVX512 load-op instructions using the broadcast feature, 0 otherwise. "],["xed_decoded_inst_uses_rflags","This returns 1 if the flags are read or written. This will return 0 otherwise. This will return 0 if the flags are really not used by this instruction. For some shifts/rotates, XED puts a flags operand in the operand array before it knows if the flags are used because of mode-dependent masking effects on the immediate.  @ingroup DEC"],["xed_decoded_inst_valid_for_chip","Indicate if this decoded instruction is valid for the specified #xed_chip_enum_t chip @ingroup DEC"],["xed_decoded_inst_vector_length_bits","@ingroup DEC Returns 128, 256 or 512 for operations in the VEX, EVEX (or XOP) encoding space and returns 0 for (most) nonvector operations. This usually the content of the VEX.L or EVEX.LL field, reinterpreted. Some GPR instructions (like the BMI1/BMI2) are encoded in the VEX space and return non-zero values from this API."],["xed_decoded_inst_zero","@ingroup DEC Zero the decode structure completely. Re-initializes all operands."],["xed_decoded_inst_zero_keep_mode","@ingroup DEC Zero the decode structure, but preserve the existing machine state/mode information. Re-initializes all operands."],["xed_decoded_inst_zero_keep_mode_from_operands","@ingroup DEC Zero the decode structure, but copy the existing machine state/mode information from the supplied operands pointer. Same as #xed_decoded_inst_zero_keep_mode."],["xed_decoded_inst_zero_set_mode","@ingroup DEC Zero the decode structure, but set the machine state/mode information. Re-initializes all operands."],["xed_decoded_inst_zeroing","Returns true if the instruction uses write-masking with zeroing @ingroup DEC"],["xed_encode","This is the main interface to the encoder. The array should be   at most 15 bytes long. The ilen parameter should indicate   this length. If the array is too short, the encoder may fail to   encode the request.  Failure is indicated by a return value of   type #xed_error_enum_t that is not equal to   #XED_ERROR_NONE. Otherwise, #XED_ERROR_NONE is returned and the   length of the encoded instruction is returned in olen."],["xed_encode_nop","This function will attempt to encode a NOP of exactly ilen bytes. If such a NOP is not encodeable, then false will be returned."],["xed_encode_request_print","@ingroup ENC        "],["xed_encoder_request_clear_rep","@ingroup ENC clear the REP prefix indicator"],["xed_encoder_request_get_iclass","@ingroup ENC"],["xed_encoder_request_get_operand_order",""],["xed_encoder_request_init_from_decode","@ingroup ENC Converts an decoder request to a valid encoder request."],["xed_encoder_request_operands","@ingroup ENC"],["xed_encoder_request_operands_const","@ingroup ENC"],["xed_encoder_request_set_agen","@ingroup ENC"],["xed_encoder_request_set_base0","@ingroup ENC"],["xed_encoder_request_set_base1","@ingroup ENC"],["xed_encoder_request_set_branch_displacement","@ingroup ENC"],["xed_encoder_request_set_effective_address_size","@ingroup ENC"],["xed_encoder_request_set_effective_operand_width","@ingroup ENC"],["xed_encoder_request_set_iclass","@ingroup ENC"],["xed_encoder_request_set_index","@ingroup ENC"],["xed_encoder_request_set_mem0","@ingroup ENC"],["xed_encoder_request_set_mem1","@ingroup ENC"],["xed_encoder_request_set_memory_displacement","@ingroup ENC"],["xed_encoder_request_set_memory_operand_length","@ingroup ENC"],["xed_encoder_request_set_operand_order",""],["xed_encoder_request_set_ptr","@ingroup ENC"],["xed_encoder_request_set_reg",""],["xed_encoder_request_set_relbr","@ingroup ENC"],["xed_encoder_request_set_rep","@ingroup ENC for REP(F3) prefix on string ops"],["xed_encoder_request_set_repne","@ingroup ENC for  REPNE(F2) prefix on string ops"],["xed_encoder_request_set_scale","@ingroup ENC"],["xed_encoder_request_set_seg0","@ingroup ENC"],["xed_encoder_request_set_seg1","@ingroup ENC"],["xed_encoder_request_set_simm","@ingroup ENC same storage as uimm0"],["xed_encoder_request_set_uimm0","@ingroup ENC Set the uimm0 using a BYTE  width."],["xed_encoder_request_set_uimm0_bits","@ingroup ENC Set the uimm0 using a BIT  width."],["xed_encoder_request_set_uimm1","@ingroup ENC"],["xed_encoder_request_zero","@ingroup ENC"],["xed_encoder_request_zero_operand_order",""],["xed_encoder_request_zero_set_mode","@ingroup ENC"],["xed_error_enum_t2str",""],["xed_error_enum_t_last",""],["xed_exception_enum_t2str",""],["xed_exception_enum_t_last",""],["xed_extension_enum_t2str",""],["xed_extension_enum_t_last",""],["xed_flag_action_action_invalid","@ingroup FLAGS     returns true if the specified action is invalid. Only the 2nd flag might be invalid."],["xed_flag_action_enum_t2str",""],["xed_flag_action_enum_t_last",""],["xed_flag_action_get_action","@ingroup FLAGS         return the action"],["xed_flag_action_get_flag_name","@ingroup FLAGS     get the name of the flag"],["xed_flag_action_print","@ingroup FLAGS     print the flag & actions"],["xed_flag_action_read_action","@ingroup FLAGS     test to see if the specific action is a read "],["xed_flag_action_read_flag","@ingroup FLAGS     returns true if either action is a read"],["xed_flag_action_write_action","@ingroup FLAGS     test to see if a specific action is a write"],["xed_flag_action_writes_flag","@ingroup FLAGS     returns true if either action is a write"],["xed_flag_enum_t2str",""],["xed_flag_enum_t_last",""],["xed_flag_set_is_subset_of","@ingroup FLAGS returns true if this object has a subset of the flags of the \"other\" object."],["xed_flag_set_print","@ingroup FLAGS print the flag set in the supplied buffer"],["xed_format_context","Disassemble the decoded instruction using the specified syntax.  The output buffer must be at least 25 bytes long. Returns true if  disassembly proceeded without errors.  @param syntax a #xed_syntax_enum_t the specifies the disassembly format  @param xedd a #xed_decoded_inst_t for a decoded instruction  @param out_buffer a buffer to write the disassembly in to.  @param buffer_len maximum length of the disassembly buffer  @param runtime_instruction_address the address of the instruction being disassembled. If zero, the offset is printed for relative branches. If nonzero, XED attempts to print the target address for relative branches.  @param context A void* used only for the call back routine for symbolic disassembly if one is provided. Can be zero.  @param symbolic_callback A function pointer for obtaining symbolic disassembly. Can be zero.  @return Returns 0 if the disassembly fails, 1 otherwise. @ingroup PRINT"],["xed_format_generic","@ingroup PRINT Disassemble the instruction information to a buffer. See the #xed_print_info_t for the required public fields of the argument. This is the preferred method of doing disassembly. The output buffer must be at least 25 bytes long.  @param pi a #xed_print_info_t  @return Returns 0 if the disassembly fails, 1 otherwise."],["xed_format_set_options","Optionally, customize the disassembly formatting options by passing  in a #xed_format_options_t structure. @ingroup PRINT"],["xed_get_byte",""],["xed_get_chip_features","fill in the contents of p with the vector of chip features."],["xed_get_copyright","@ingroup INIT Returns a copyright string."],["xed_get_cpuid_bit_for_isa_set","Returns the name of the i'th cpuid bit associated with this isa-set. Call this repeatedly, with 0 <= i < XED_MAX_CPUID_BITS_PER_ISA_SET. Give up when i == XED_MAX_CPUID_BITS_PER_ISA_SET or the return value is XED_CPUID_BIT_INVALID."],["xed_get_cpuid_rec","This provides the details of the CPUID bit specification, if the enumeration value is not sufficient.  Returns 1 on success and fills in the structure pointed to by p. Returns 0 on failure."],["xed_get_largest_enclosing_register","Returns the largest enclosing register for any kind of register; This  is mostly useful for GPRs. (64b mode assumed) @ingroup REGINTFC"],["xed_get_largest_enclosing_register32","Returns the largest enclosing register for any kind of register; This  is mostly useful for GPRs in 32b mode. @ingroup REGINTFC"],["xed_get_register_width_bits","Returns the  width, in bits, of the named register. 32b mode @ingroup REGINTFC"],["xed_get_register_width_bits64","Returns the  width, in bits, of the named register. 64b mode. @ingroup REGINTFC"],["xed_get_version","@ingroup INIT Returns a string representing XED svn commit revision and time stamp."],["xed_gpr_reg_class","Returns the specific width GPR reg class (like XED_REG_CLASS_GPR32 or   XED_REG_CLASS_GPR64)   for a given GPR register. Or XED_REG_INVALID if not a GPR. @ingroup REGINTFC"],["xed_iclass_enum_t2str",""],["xed_iclass_enum_t_last",""],["xed_iform_enum_t2str",""],["xed_iform_enum_t_last",""],["xed_iform_first_per_iclass","@ingroup IFORM Return the first of the iforms for a particular iclass.  This function returns valid data as soon as global data is initialized. (This function does not require a decoded instruction as input)."],["xed_iform_map","@ingroup IFORM Map the #xed_iform_enum_t to a pointer to a #xed_iform_info_t which indicates the #xed_iclass_enum_t, the #xed_category_enum_t and the #xed_extension_enum_t for the iform. Returns 0 if the iform is not a valid iform."],["xed_iform_max_per_iclass","@ingroup IFORM Return the maximum number of iforms for a particular iclass.  This function returns valid data as soon as global data is initialized. (This function does not require a decoded instruction as input)."],["xed_iform_to_category","@ingroup IFORM Return the category for a given iform. This  function returns valid data as soon as global data is initialized. (This function does not require a decoded instruction as input)."],["xed_iform_to_extension","@ingroup IFORM Return the extension for a given iform. This function returns valid data as soon as global data is initialized. (This function does not require a decoded instruction as input)."],["xed_iform_to_iclass_string_att","@ingroup IFORM Return a pointer to a character string of the iclass. This translates the internal disambiguated names to the more ambiguous names that people like to see. This returns the ATT SYSV-syntax name."],["xed_iform_to_iclass_string_intel","@ingroup IFORM Return a pointer to a character string of the iclass. This translates the internal disambiguated names to the more ambiguous names that people like to see. This returns the Intel-syntax name."],["xed_iform_to_isa_set","@ingroup IFORM Return the isa_set for a given iform. This function returns valid data as soon as global data is initialized. (This function does not require a decoded instruction as input)."],["xed_iformfl_enum_t_last",""],["xed_ild_decode","This function just does instruction length decoding. It does not return a fully decoded instruction.  @param xedd  the decoded instruction of type #xed_decoded_inst_t .               Mode/state sent in via xedd; See the #xed_state_t .  @param itext the pointer to the array of instruction text bytes  @param bytes the length of the itext input array.              1 to 15 bytes, anything more is ignored. @return #xed_error_enum_t indicating success (#XED_ERROR_NONE) or       failure. Only two failure codes are valid for this function:  #XED_ERROR_BUFFER_TOO_SHORT and #XED_ERROR_GENERAL_ERROR. In general this function cannot tell if the instruction is valid or not. For valid instructions, XED can figure out if enough bytes were provided to decode the instruction. If not enough were provided, XED returns #XED_ERROR_BUFFER_TOO_SHORT.  From this function, the #XED_ERROR_GENERAL_ERROR is an indication that XED could not decode the instruction's length because  the instruction was so invalid that even its length may across implmentations."],["xed_init_print_info","@ingroup PRINT"],["xed_inst_cpl","@ingroup DEC  xed_inst_cpl() is DEPRECATED. Please use      \"xed_decoded_inst_get_attribute(xedd, XED_ATTRIBUTE_RING0)\"   instead. Return the current privilege level (CPL) required for execution, 0 or 3. If the value is zero, then the instruction can only execute in ring 0."],["xed_inst_flag_info_index",""],["xed_inst_get_attribute","@ingroup DEC Scan for the attribute attr and return 1 if it is found, 0 otherwise."],["xed_inst_get_attributes","@ingroup DEC Return the attributes bit vector"],["xed_inst_operand","@ingroup DEC Obtain a pointer to an individual operand"],["xed_inst_table_base","@ingroup DEC Return the base of instruction table."],["xed_internal_assert",""],["xed_isa_set_enum_t2str",""],["xed_isa_set_enum_t_last",""],["xed_itoa",""],["xed_itoa_hex","defaults to lowercase"],["xed_itoa_hex_ul",""],["xed_itoa_hex_zeros","defaults to lowercase"],["xed_machine_mode_enum_t2str",""],["xed_machine_mode_enum_t_last",""],["xed_modify_chip_features","present = 1 to turn the feature on. present=0 to remove the feature."],["xed_nonterminal_enum_t2str",""],["xed_nonterminal_enum_t_last",""],["xed_norep_map","@ingroup DEC Take an #xed_iclass_enum_t value for an instruction with a REP/REPNE/REPE prefix and return the corresponding #xed_iclass_enum_t without that prefix. If the input instruction does not have a REP/REPNE/REPE prefix, this function returns XED_ICLASS_INVALID."],["xed_operand_action_conditional_read",""],["xed_operand_action_conditional_write",""],["xed_operand_action_enum_t2str",""],["xed_operand_action_enum_t_last",""],["xed_operand_action_read",""],["xed_operand_action_read_and_written",""],["xed_operand_action_read_only",""],["xed_operand_action_written",""],["xed_operand_action_written_only",""],["xed_operand_conditional_read","@ingroup DEC If the operand has a conditional read (may also write)"],["xed_operand_conditional_write","@ingroup DEC If the operand has a conditional write (may also read)"],["xed_operand_convert_enum_t2str",""],["xed_operand_convert_enum_t_last",""],["xed_operand_element_type_enum_t2str",""],["xed_operand_element_type_enum_t_last",""],["xed_operand_element_xtype_enum_t2str",""],["xed_operand_element_xtype_enum_t_last",""],["xed_operand_enum_t2str",""],["xed_operand_enum_t_last",""],["xed_operand_print","@ingroup DEC Print the operand p into the buffer buf, of length buflen. @param p  an operand template,  #xed_operand_t. @param buf buffer that gets filled in @param buflen maximum buffer length"],["xed_operand_read","@ingroup DEC If the operand is read, including conditional reads"],["xed_operand_read_and_written","@ingroup DEC If the operand is read-and-written, conditional reads and conditional writes"],["xed_operand_read_only","@ingroup DEC If the operand is read-only, including conditional reads"],["xed_operand_type_enum_t2str",""],["xed_operand_type_enum_t_last",""],["xed_operand_values_accesses_memory","@ingroup OPERANDS    "],["xed_operand_values_branch_not_taken_hint","@ingroup OPERANDS    "],["xed_operand_values_branch_taken_hint","@ingroup OPERANDS    "],["xed_operand_values_clear_rep","@ingroup OPERANDS     DO NOT USE - DEPRECATED. The  correct way to do remove a rep prefix is by changing the iclass"],["xed_operand_values_dump","@ingroup OPERANDS Dump all the information about the operands to buf."],["xed_operand_values_get_atomic","@ingroup OPERANDS     Returns true if the memory operation has atomic read-modify-write semantics. An XCHG accessing memory is atomic with or without a LOCK prefix."],["xed_operand_values_get_base_reg","@ingroup OPERANDS    "],["xed_operand_values_get_branch_displacement_byte","@ingroup OPERANDS    "],["xed_operand_values_get_branch_displacement_int32","@ingroup OPERANDS    "],["xed_operand_values_get_branch_displacement_length","@ingroup OPERANDS Return the branch displacement width in bytes"],["xed_operand_values_get_branch_displacement_length_bits","@ingroup OPERANDS Return the branch displacement width in bits"],["xed_operand_values_get_displacement_for_memop","@ingroup OPERANDS     Deprecated. Compatibility function for XED0. See has_memory_displacement()."],["xed_operand_values_get_effective_address_width","@ingroup OPERANDS     Returns The effective address width in bits: 16/32/64. "],["xed_operand_values_get_effective_operand_width","@ingroup OPERANDS     Returns The effective operand width in bits: 16/32/64. Note this is not the same as the width of the operand which can vary! For 8 bit operations, the effective operand width is the machine mode's default width. If you also want to identify byte operations use the higher level function #xed_decoded_inst_get_operand_width() ."],["xed_operand_values_get_iclass","@ingroup OPERANDS    "],["xed_operand_values_get_immediate_byte","@ingroup OPERANDS     Return the i'th byte of the immediate"],["xed_operand_values_get_immediate_int64","@ingroup OPERANDS    "],["xed_operand_values_get_immediate_is_signed","@ingroup OPERANDS Return true if the first immediate (IMM0) is signed"],["xed_operand_values_get_immediate_uint64","@ingroup OPERANDS    "],["xed_operand_values_get_index_reg","@ingroup OPERANDS    "],["xed_operand_values_get_long_mode","@ingroup OPERANDS    "],["xed_operand_values_get_memory_displacement_byte","@ingroup OPERANDS    "],["xed_operand_values_get_memory_displacement_int64","Returns the potentially scaled value of the memory displacement. Certain AVX512 memory displacements are scaled before they are used.  @ingroup OPERANDS"],["xed_operand_values_get_memory_displacement_int64_raw","Returns the unscaled (raw) memory displacement. Certain AVX512 memory displacements are scaled before they are used.  @ingroup OPERANDS"],["xed_operand_values_get_memory_displacement_length","@ingroup OPERANDS Return the memory displacement width in BYTES"],["xed_operand_values_get_memory_displacement_length_bits","@ingroup OPERANDS Return the memory displacement width in BITS"],["xed_operand_values_get_memory_displacement_length_bits_raw","@ingroup OPERANDS Return the raw memory displacement width in BITS(ignores scaling)"],["xed_operand_values_get_memory_operand_length","return bytes @ingroup OPERANDS    "],["xed_operand_values_get_real_mode","@ingroup OPERANDS    "],["xed_operand_values_get_scale","@ingroup OPERANDS    "],["xed_operand_values_get_second_immediate","@ingroup OPERANDS    "],["xed_operand_values_get_seg_reg","@ingroup OPERANDS    "],["xed_operand_values_get_stack_address_width","@ingroup OPERANDS     Returns The stack address width in bits: 16/32/64. "],["xed_operand_values_has_66_prefix","@ingroup OPERANDS     This includes any 66 prefix that shows up even if it is ignored."],["xed_operand_values_has_address_size_prefix","@ingroup OPERANDS     This indicates the presence of a 67 prefix."],["xed_operand_values_has_branch_displacement","@ingroup OPERANDS     True if there is a branch displacement"],["xed_operand_values_has_disp","@ingroup OPERANDS     ALIAS for has_displacement(). Deprecated. See has_memory_displacement() and has_branch_displacement()."],["xed_operand_values_has_displacement","@ingroup OPERANDS     True if there is a memory or branch displacement"],["xed_operand_values_has_immediate","@ingroup OPERANDS     Return true if there is an immediate operand"],["xed_operand_values_has_lock_prefix","@ingroup OPERANDS     Returns true if the memory operation has a valid lock prefix."],["xed_operand_values_has_memory_displacement","@ingroup OPERANDS     True if there is a memory displacement"],["xed_operand_values_has_modrm_byte","@ingroup OPERANDS Returns true if the instruction has a MODRM byte."],["xed_operand_values_has_operand_size_prefix","@ingroup OPERANDS     This does not include the cases when the 66 prefix is used an opcode-refining prefix for multibyte opcodes."],["xed_operand_values_has_real_rep","@ingroup OPERANDS     True if the instruction has a real REP prefix. This returns false if there is no F2/F3 prefix or the F2/F3 prefix is used to refine the opcode as in some SSE operations."],["xed_operand_values_has_rep_prefix","@ingroup OPERANDS     True if the instruction as a F3 REP prefix (used for opcode refining, for rep for string operations, or ignored)."],["xed_operand_values_has_repne_prefix","@ingroup OPERANDS     True if the instruction as a F2 REP prefix (used for opcode refining, for rep for string operations, or ignored)."],["xed_operand_values_has_rexw_prefix","@ingroup OPERANDS     This instruction has a REX prefix with the W bit set."],["xed_operand_values_has_segment_prefix","@ingroup OPERANDS    "],["xed_operand_values_has_sib_byte","@ingroup OPERANDS Returns true if the instruction has a SIB byte."],["xed_operand_values_init","@ingroup OPERANDS Initializes operand structure"],["xed_operand_values_init_keep_mode","@ingroup OPERANDS Initializes dst operand structure but preserves the existing MODE/SMODE values from the src operand structure."],["xed_operand_values_init_set_mode","@ingroup OPERANDS Initializes the operand storage and sets mode values."],["xed_operand_values_is_nop","@ingroup OPERANDS    "],["xed_operand_values_is_prefetch","@ingroup OPERANDS    "],["xed_operand_values_lockable","@ingroup OPERANDS Returns true if the instruction could be re-encoded to have a lock prefix but does not have one currently."],["xed_operand_values_memop_without_modrm","@ingroup OPERANDS     Returns true if the instruction access memory but without using a MODRM byte limiting its addressing modes."],["xed_operand_values_number_of_memory_operands","@ingroup OPERANDS    "],["xed_operand_values_print_short","@ingroup OPERANDS More tersely dump all the information about the operands to buf."],["xed_operand_values_segment_prefix","@ingroup OPERANDS     Return the segment prefix, if any, as a #xed_reg_enum_t value."],["xed_operand_values_set_base_reg","@ingroup OPERANDS    "],["xed_operand_values_set_branch_displacement","@ingroup OPERANDS     Set the branch displacement using a BYTES length"],["xed_operand_values_set_branch_displacement_bits","@ingroup OPERANDS     Set the branch displacement using a BITS length"],["xed_operand_values_set_effective_address_width","@ingroup OPERANDS width is bits 16, 32, 64"],["xed_operand_values_set_effective_operand_width","@ingroup OPERANDS width is bits 8, 16, 32, 64"],["xed_operand_values_set_iclass","@ingroup OPERANDS    "],["xed_operand_values_set_immediate_signed","@ingroup OPERANDS     Set the signed immediate using a BYTES length"],["xed_operand_values_set_immediate_signed_bits","@ingroup OPERANDS     Set the signed immediate using a BITS length"],["xed_operand_values_set_immediate_unsigned","@ingroup OPERANDS     Set the unsigned immediate using a BYTE length."],["xed_operand_values_set_immediate_unsigned_bits","@ingroup OPERANDS     Set the unsigned immediate using a BIT length."],["xed_operand_values_set_index_reg","@ingroup OPERANDS    "],["xed_operand_values_set_lock","@ingroup OPERANDS    "],["xed_operand_values_set_memory_displacement","@ingroup OPERANDS     Set the memory displacement using a BYTES length"],["xed_operand_values_set_memory_displacement_bits","@ingroup OPERANDS     Set the memory displacement using a BITS length"],["xed_operand_values_set_memory_operand_length","takes bytes, not bits, as an argument @ingroup OPERANDS    "],["xed_operand_values_set_mode","@ingroup OPERANDS Set the mode values"],["xed_operand_values_set_operand_reg","@ingroup OPERANDS     Set the operand storage field entry named 'operand_name' to the register value specified by 'reg_name'."],["xed_operand_values_set_relbr","@ingroup OPERANDS     Indicate that we have a relative branch."],["xed_operand_values_set_scale","@ingroup OPERANDS    "],["xed_operand_values_set_seg_reg","@ingroup OPERANDS    "],["xed_operand_values_using_default_segment","@ingroup OPERANDS     Indicates if the default segment is being used. @param[in] p   the pointer to the #xed_operand_values_t structure. @param[in] i   0 or 1, indicating which memory operation. @return true if the memory operation is using the default segment for the associated addressing mode base register."],["xed_operand_values_zero_branch_displacement","@ingroup OPERANDS    "],["xed_operand_values_zero_immediate","@ingroup OPERANDS    "],["xed_operand_values_zero_memory_displacement","@ingroup OPERANDS    "],["xed_operand_values_zero_segment_override","@ingroup OPERANDS    "],["xed_operand_visibility_enum_t2str",""],["xed_operand_visibility_enum_t_last",""],["xed_operand_width_bits","@ingroup DEC @param p  an operand template,  #xed_operand_t. @param eosz  effective operand size of the instruction,  1 | 2 | 3 for   16 | 32 | 64 bits respectively. 0 is invalid. @return  the actual width of operand in bits. See xed_decoded_inst_operand_length_bits() for a more general solution."],["xed_operand_width_enum_t2str",""],["xed_operand_width_enum_t_last",""],["xed_operand_written","@ingroup DEC If the operand is written, including conditional writes"],["xed_operand_written_only","@ingroup DEC If the operand is written-only, including conditional writes"],["xed_reg_class","Returns the register class of the given input register. @ingroup REGINTFC"],["xed_reg_class_enum_t2str",""],["xed_reg_class_enum_t_last",""],["xed_reg_enum_t2str",""],["xed_reg_enum_t_last",""],["xed_register_abort_function","@ingroup INIT This is for registering a function to be called during XED's assert processing. If you do not register an abort function, then the system's abort function will be called. If your supplied function returns, then abort() will still be called."],["xed_rep_map","@ingroup DEC Take an #xed_iclass_enum_t value without a REP prefix and return the corresponding #xed_iclass_enum_t with a REP prefix. If the input instruction cannot have a REP prefix, this function returns XED_ICLASS_INVALID."],["xed_rep_remove","@ingroup DEC Take an instruction with a REP/REPE/REPNE prefix and return the corresponding xed_iclass_enum_t without that prefix. The return value differs from the other functions in this group: If the input iclass does not have REP/REPNE/REPE prefix, the function returns the original instruction."],["xed_repe_map","@ingroup DEC Take an #xed_iclass_enum_t value without a REPE prefix and return the corresponding #xed_iclass_enum_t with a REPE prefix. If the input instruction cannot have have a REPE prefix, this function returns XED_ICLASS_INVALID."],["xed_repne_map","@ingroup DEC Take an #xed_iclass_enum_t value without a REPNE prefix and return the corresponding #xed_iclass_enum_t with a REPNE prefix. If the input instruction cannot have a REPNE prefix, this function returns XED_ICLASS_INVALID."],["xed_set_log_file","Set the FILE* for XED's log msgs. This takes a FILE* as a void* because some software defines their own FILE* types creating conflicts."],["xed_set_verbosity","Set the verbosity level for XED"],["xed_shortest_width_signed","returns the number of bytes required to store the SIGNED number x given a mask of legal lengths. For the legal_widths argument, bit 0 implies 1 byte is a legal return width, bit 1 implies that 2 bytes is a legal return width, bit 2 implies that 4 bytes is a legal return width.  This returns 8 (indicating 8B) if none of the provided legal widths applies."],["xed_shortest_width_unsigned","returns the number of bytes required to store the UNSIGNED number x given a mask of legal lengths. For the legal_widths argument, bit 0 implies 1 byte is a legal return width, bit 1 implies that 2 bytes is a legal return width, bit 2 implies that 4 bytes is a legal return width. This returns 8 (indicating 8B) if none of the provided legal widths applies."],["xed_sign_extend16_32",""],["xed_sign_extend16_64",""],["xed_sign_extend32_64",""],["xed_sign_extend8_16",""],["xed_sign_extend8_32",""],["xed_sign_extend8_64",""],["xed_sign_extend_arbitrary_to_32","arbitrary sign extension from a qty of \"bits\" length to 32b "],["xed_sign_extend_arbitrary_to_64","arbitrary sign extension from a qty of \"bits\" length to 64b "],["xed_simple_flag_get_flag_action","@ingroup FLAGS return the specific flag-action. Very detailed low level information"],["xed_simple_flag_get_may_write","@ingroup FLAGS Indicates the flags are only conditionally written. Usually MAY-writes of the flags instructions that are dependent on a REP count."],["xed_simple_flag_get_must_write","@ingroup FLAGS the flags always written"],["xed_simple_flag_get_nflags","@ingroup FLAGS returns the number of flag-actions"],["xed_simple_flag_get_read_flag_set","@ingroup FLAGS return union of bits for read flags"],["xed_simple_flag_get_undefined_flag_set","@ingroup FLAGS   return union of bits for undefined flags"],["xed_simple_flag_get_written_flag_set","@ingroup FLAGS   return union of bits for written flags"],["xed_simple_flag_print","@ingroup FLAGS     print the flags"],["xed_simple_flag_reads_flags","@ingroup FLAGS     boolean test to see if flags are read, scans the flags"],["xed_simple_flag_writes_flags","@ingroup FLAGS     boolean test to see if flags are written, scans the flags"],["xed_state_print","@ingroup INIT"],["xed_strcat",""],["xed_strcpy",""],["xed_strlen",""],["xed_strncat","returns the number of bytes remaining for the next use of #xed_strncpy() or #xed_strncat() ."],["xed_strncpy","returns the number of bytes remaining for the next use of #xed_strncpy() or #xed_strncat() ."],["xed_syntax_enum_t2str",""],["xed_syntax_enum_t_last",""],["xed_tables_init","@ingroup INIT This is the call to initialize the XED encode and decode tables. It must be called once before using XED."],["xed_zero_extend16_32",""],["xed_zero_extend16_64",""],["xed_zero_extend32_64",""],["xed_zero_extend8_16",""],["xed_zero_extend8_32",""],["xed_zero_extend8_64",""]],"static":[["xed_verbose",""]],"struct":[["__BindgenUnionField",""],["xed_attributes_t",""],["xed_chip_features_t","@ingroup ISASET"],["xed_cpuid_rec_t",""],["xed_decoded_inst_s","@ingroup DEC The main container for instructions. After decode, it holds an array of operands with derived information from decode and also valid #xed_inst_t pointer which describes the operand templates and the operand order.  See @ref DEC for API documentation."],["xed_decoded_inst_s__bindgen_ty_1",""],["xed_decoded_inst_s__bindgen_ty_2",""],["xed_decoder_vars_s",""],["xed_enc_displacement_t",""],["xed_encoder_iforms_s",""],["xed_encoder_instruction_t",""],["xed_encoder_operand_t",""],["xed_encoder_operand_t__bindgen_ty_1",""],["xed_encoder_operand_t__bindgen_ty_1__bindgen_ty_1",""],["xed_encoder_prefixes_t",""],["xed_encoder_prefixes_t__bindgen_ty_1",""],["xed_encoder_vars_s",""],["xed_flag_enum_s","@ingroup FLAGS Associated with each flag field there can be one action."],["xed_flag_set_s","@ingroup FLAGS a union of flags bits"],["xed_flag_set_s__bindgen_ty_1",""],["xed_format_options_t","Options for the disasembly formatting functions. Set once during initialization by a calling #xed_format_set_options  @ingroup PRINT"],["xed_iform_info_s","@ingroup IFORM Statically available information about iforms. Values are returned by #xed_iform_map()."],["xed_inst_s","@ingroup DEC constant information about a decoded instruction form, including the pointer to the constant operand properties #xed_operand_t for this instruction form."],["xed_memop_t",""],["xed_operand_s","@ingroup DEC  Constant information about an individual generic operand, like an operand template, describing the operand properties. See @ref DEC for API information."],["xed_operand_s__bindgen_ty_1",""],["xed_operand_storage_s",""],["xed_print_info_t","@ingroup PRINT This contains the information used by the various disassembly printers. Call xed_init_print_info to initialize the fields.  Then change the required and optional fields when required."],["xed_simple_flag_s","@ingroup FLAGS A collection of #xed_flag_action_t's and unions of read and written flags"],["xed_state_s","Encapsulates machine modes for decoder/encoder requests. It specifies the machine operating mode as a  #xed_machine_mode_enum_t  for decoding and encoding. The machine mode corresponds to the default data operand width for that mode. For all modes other than the 64b long mode (XED_MACHINE_MODE_LONG_64), a default addressing width, and a stack addressing width must be supplied of type #xed_address_width_enum_t .  @ingroup INIT"],["xed_union16_t",""],["xed_union16_t__bindgen_ty_1",""],["xed_union32_t",""],["xed_union32_t__bindgen_ty_1",""],["xed_union32_t__bindgen_ty_2",""],["xed_union64_t",""],["xed_union64_t__bindgen_ty_1",""],["xed_union64_t__bindgen_ty_2",""],["xed_union64_t__bindgen_ty_3",""]],"type":[["int_fast16_t",""],["int_fast32_t",""],["int_fast64_t",""],["int_fast8_t",""],["int_least16_t",""],["int_least32_t",""],["int_least64_t",""],["int_least8_t",""],["intmax_t",""],["uint_fast16_t",""],["uint_fast32_t",""],["uint_fast64_t",""],["uint_fast8_t",""],["uint_least16_t",""],["uint_least32_t",""],["uint_least64_t",""],["uint_least8_t",""],["uintmax_t",""],["xed_addr_t",""],["xed_bits_t",""],["xed_bool_t",""],["xed_decoded_inst_t",""],["xed_disassembly_callback_fn_t","@param address The input address for which we want symbolic name and offset @param symbol_buffer A buffer to hold the symbol name. The callback function should fill this in and terminate                      with a null byte. @param buffer_length The maximum length of the symbol_buffer including then null @param offset A pointer to a xed_uint64_t to hold the offset from the provided symbol. @param context This void* pointer passed to the disassembler's new interface so that the caller can identify                     the proper context against which to resolve the symbols.                     The disassembler passes this value to                    the callback. The legacy formatters                     that do not have context will pass zero for this parameter. @return 0 on failure, 1 on success."],["xed_encoder_iforms_t",""],["xed_encoder_request_s","@ingroup ENC"],["xed_encoder_request_t","@ingroup ENC"],["xed_flag_action_t",""],["xed_flag_set_t",""],["xed_iform_info_t",""],["xed_inst_t",""],["xed_int_t",""],["xed_operand_extractor_fn_t",""],["xed_operand_storage_t",""],["xed_operand_t",""],["xed_operand_values_t",""],["xed_register_callback_fn_t","A function for obtaining register values. 32b return values should be zero extended to 64b. The error value is set to nonzero if the callback experiences some sort of problem.  @ingroup AGEN"],["xed_segment_base_callback_fn_t","A function for obtaining the segment base values. 32b return values should be zero extended zero extended to 64b. The error value is set to nonzero if the callback experiences some sort of problem.  @ingroup AGEN"],["xed_simple_flag_t",""],["xed_state_t",""],["xed_uint_t",""],["xed_user_abort_function_t",""]]});